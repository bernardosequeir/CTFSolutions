{"componentChunkName":"component---src-templates-blog-post-js","path":"/under_the_wire/century/Century_writeup_complete/","result":{"data":{"markdownRemark":{"html":"<h1>Under The Wire Century Wargame Write-Up</h1>\n<p><strong><a href=\"http://underthewire.tech/century/century.htm\">Century</a></strong> is the easiest wargame offered by the crew at <a href=\"http://underthewire.tech/\">UnderTheWire</a>, who I think are the same people behind the more popular <a href=\"http://overthewire.org/wargames/\">OverTheWire</a>, while OtW offers challenges more geared to Linux/ *nix users, UtW focuses on the Windows side of things. In this introductory one we learn how to do some very basic stuff in powershell, just to get our feet wet in this side of the pond. In terms of difficulty, its most direct comparison would be Bandit (from OtW), but as it is much shorter, it's even easier than that. The hardest challenge here is trying to learn something from the Powershell docs imo.</p>\n<p>So, I hope you you enjoy the Write-Up and if you have any doubts don't be afraid to shoot me an e-mail. </p>\n<h3>Century 1 -> 2</h3>\n<p>This level is very simple, as the password is just the build version of powershell running on the server.\nTo determine the version, you only need to type: </p>\n<pre><code class=\"language-powershell\">    $PSVersionTable\n</code></pre>\n<p>The output of that command will be a table sorta like this one :</p>\n<pre><code class=\"language-powershell\">Name                           Value\n----                           -----\nPSVersion                      5.1.14393.2636\nPSEdition                      Desktop\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}\nBuildVersion                   10.0.14393.2636\nCLRVersion                     4.0.30319.42000\nWSManStackVersion              3.0\nPSRemotingProtocolVersion      2.3\nSerializationVersion           1.1.0.1\n</code></pre>\n<p>So in this case the password is <em>10.0.14393.2636</em></p>\n<h3>Century 2 -> 3</h3>\n<p>This level continues to ease us into Powershell, now the new password is the the name of the built-in cmdlet that \"emulates\" wget and the name of the file that is on the user's desktop.</p>\n<p>To get the name of the cmdlet you can just run:</p>\n<pre><code class=\"language-powershell\">PS C:\\Users\\century2\\Documents> Get-Alias wget\n\nCommandType     Name                      Version    Source\n-----------     ----                      -------    ------\nAlias           wget -> Invoke-WebRequest\n</code></pre>\n<p>And you can get the filename just as easy with:</p>\n<pre><code class=\"language-powershell\">PS C:\\Users\\century2\\Documents> ls ..\\Desktop\n\n\n    Directory: C:\\Users\\century2\\Desktop\n\n\nMode                LastWriteTime         Length Name\n----                -------------         ------ ----\n-a----        8/30/2018   3:29 AM            693 443\n</code></pre>\n<p>So the password is just <em>invoke-webrequest443</em> (lowercase as indicated on the challenge page)</p>\n<h3>Century 3 -> 4</h3>\n<p>Still an easy one, the password is just the number of files on the user's desktop. It's the first time we have to use a Powershell command though. (Obviously all we've used until now are Powershell commands but aliased as their bash names). The solution is just: </p>\n<pre><code class=\"language-powershell\">PS C:\\Users\\century3\\documents> echo ( ls ..\\Desktop | Measure-Object).Count\n123\n</code></pre>\n<p>Onwards to century4 with 123 we go.</p>\n<h3>Century 4 -> 5</h3>\n<p>Now this one has a trick, the password is still just a filename but the file is inside a folder which has spaces, but you can circumvent it using tab-completion, just write the C and then hit tab and it will expand to the full name, as pictured below:</p>\n<pre><code class=\"language-powershell\">PS C:\\Users\\century4\\Documents> ls '..\\Desktop\\Can You Open Me'\n\n\n    Directory: C:\\Users\\century4\\Desktop\\Can You Open Me\n\n\nMode                LastWriteTime         Length Name\n----                -------------         ------ ----\n-a----        8/30/2018   3:29 AM             24 61580\n</code></pre>\n<h3>Century 5 -> 6</h3>\n<p>So this one is a little bit trickier, the password is the short name of the domain where the machine is and the name of the file on the desktop.</p>\n<p>Poking around on google there's a really easy command that returns the domain name</p>\n<pre><code class=\"language-powershell\">PS C:\\Users\\century5\\documents> (gwmi Win32_NTDomain).DomainName\nunderthewire\n</code></pre>\n<p>And as we've done a couple of times now, we get the filename like this</p>\n<pre><code class=\"language-powershell\">PS C:\\Users\\century5\\documents> ls ..\\Desktop\n\n\n    Directory: C:\\Users\\century5\\Desktop\n\n\nMode                LastWriteTime         Length Name\n----                -------------         ------ ----\n-a----        8/30/2018   3:29 AM             54 3347\n</code></pre>\n<p>So, the password would just be <em>underthewire3347</em></p>\n<h3>Century 6 -> 7</h3>\n<p>The solution to this one is the same as Century 3, I was afraid we'd have to learn how to filter files and folders, but appears not, since the solution worked right away for me.</p>\n<pre><code class=\"language-powershell\">PS C:\\Users\\century6\\documents> echo ( ls ..\\Desktop | Measure-Object).Count\n197\n</code></pre>\n<h3>Century 7 -> 8</h3>\n<p>The password for this level is the content of a file hidden inside the user's folders. All we know is that the password is inside a readme so, if we search for a command that works similar to grep we find that <strong><em>Get-ChildItem</em></strong> (aliased as ls in the example below) is capable of doing just that. All we have to do is cd into the parent folder of the user and search for a file that <em>includes</em> read and do it <em>recursively</em>, so that it searches every folder available.</p>\n<pre><code class=\"language-powershell\">PS C:\\Users\\century7\\documents> cd ..\nPS C:\\Users\\century7> ls -Include *read* -Recurse\n\n\n    Directory: C:\\Users\\century7\\Downloads\n\n\nMode                LastWriteTime         Length Name\n----                -------------         ------ ----\n-a----        8/30/2018   3:29 AM              7 Readme\n</code></pre>\n<p>Now that we know where the file is, we just nead to cat (<strong><em>Get-Content</em></strong> alias) it out</p>\n<pre><code class=\"language-powershell\">PS C:\\Users\\century7> cat .\\Downloads\\Readme\n7points\n</code></pre>\n<p>So the password is just <em>7points</em>.</p>\n<h3>Century 8 -> 9</h3>\n<p>The password for this level is the number of unique lines on the file on the file on the desktop. So, using our bash trained minds, we instantly think of <code>sort | uniq</code>, so translating to Powershell, we can use <strong><em>Get-Unique</em></strong>, in bash we'd have to sort it first, due to how uniq works, but here <strong><em>Get-Unique</em></strong> works by itself. So we can just count the lines left after removing duplicates. </p>\n<pre><code class=\"language-powershell\">PS C:\\Users\\century8\\Desktop> (cat .\\unique.txt | Get-Unique).count\n696\n</code></pre>\n<p>The password is <em>696</em>.</p>\n<h3>Century 9 -> 10</h3>\n<p>This level asks for us to retrieve the 161th word of the document on the desktop, which is really simple, we just have to open the file, split it using <strong><em>split(\" \")</em></strong> and then get the desired item, which we can do with brackets, like this:</p>\n<pre><code class=\"language-powershell\">PS C:\\Users\\century9\\Desktop> (cat .\\Word_File.txt).split(\" \")[160]\npierid\n</code></pre>\n<h3>Century 10 -> 11</h3>\n<p>We need to get the 10th and the 8th word of the description of the windows update service and the name of the file on the desktop, with <strong><em>Get-Service</em></strong>, you get a list of all the services that machine has, and at the bottom of the list you can see <em>wuauserv</em>, the name of the windows update service. </p>\n<pre><code class=\"language-powershell\">PS C:\\Users\\century10\\documents> Get-WMIObject -Class Win32_Service -Filter \"Nam\ne='wuauserv'\" | Select-Object Description | Format-Table -Wrap\n\nDescription\n-----------\nEnables the detection, download, and installation of updates for Windows and\nother programs. If this service is disabled, users of this computer will not\nbe able to use Windows Update or its automatic updating feature, and programs\nwill not be able to use the Windows Update Agent (WUA) API.\n</code></pre>\n<p>So you need to get the service, needing to use a filter to get it, yeah, that threw me for a loop. So then you need to use <strong><em>Select-Object</em></strong>, and get the Description field, but because and it doesn't fit there you need to use <strong><em>Format-Table</em></strong>.</p>\n<p>Getting the name of the desktop is trivial at this time so, the password is <em>windowsupdates110</em></p>\n<h3>Century 11 -> 12</h3>\n<p>For this one we need to get the name of a file hidden \"within the contacts, desktop, documents, downloads, favorites, music,or videos folder in the user's profile\", so while it would have been possible to just go to the home folder of the user and recursively check on all folders, because they were so few folders i just went and guessed where it would be, and i finally found it on the downloads folder. To find hidden files you can just tack on <strong><em>Force</em></strong> on <strong><em>Get-Childitem</em></strong>.</p>\n<pre><code class=\"language-powershell\">PS C:\\Users\\century11> cd .\\Downloads\nPS C:\\Users\\century11\\Downloads> ls -Force\n\n\n    Directory: C:\\Users\\century11\\Downloads\n\n\nMode                LastWriteTime         Length Name  \n----                -------------         ------ ----\n--rh--        8/30/2018   3:34 AM             30 secret_sauce\n</code></pre>\n<h3>Century 12 -> 13</h3>\n<p>The password for this level is the description of the domain's controller computer, plus the name of the file on the desktop, so, to get the description of the domain's controller, we use <strong><em>Get-ADDomainController</em></strong>.</p>\n<pre><code class=\"language-powershell\">    PS C:\\Users\\century12\\Desktop> Get-ADDomainController\n\n\nComputerObjectDN           : CN=UTW,OU=Domain\n                             Controllers,DC=underthewire,DC=tech\nDefaultPartition           : DC=underthewire,DC=tech\nDomain                     : underthewire.tech\nEnabled                    : True\nForest                     : underthewire.tech\nHostName                   : utw.underthewire.tech\nInvocationId               : 09ee1897-2210-4ac9-989d-e19b4241e9c6\nIPv4Address                : 192.99.167.156\n...\n</code></pre>\n<p>The ComputerObjectDN value gives us the domain's controller computer name (CN), so if we use <strong><em>Get-ADComputer</em></strong>, we can get the information we want.</p>\n<pre><code class=\"language-powershell\">PS C:\\Users\\century12\\Desktop> Get-ADComputer -Filter {Name -eq \"UTW\"} -Prop Des\ncription\n\n\nDescription       : I_Authenticate\nDistinguishedName : CN=UTW,OU=Domain Controllers,DC=underthewire,DC=tech\nDNSHostName       : utw.underthewire.tech\nEnabled           : True\nName              : UTW\nObjectClass       : computer\nObjectGUID        : 5ca56844-bb73-4234-ac85-eed2d0d01a2e\nSamAccountName    : UTW$\nSID               : S-1-5-21-758131494-606461608-3556270690-1000\nUserPrincipalName :\n</code></pre>\n<p>The password is <em>i<em>authenticate</em>things</em> (the name of the file on the desktop).</p>\n<h3>Century 13 -> 14</h3>\n<p>This one introduces a new cmdlet to use, <strong><em>Measure-Object</em></strong>. This cmdlet is very useful to know how many words, lines, characters, and seemingly <em><a href=\"https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/measure-object?view=powershell-6\">almost everything?</a></em>.\nTo figure out the number of words in this file, we can just pipe it to the cmdlet and then specify that we want the number of words.</p>\n<pre><code class=\"language-powershell\">PS C:\\Users\\century13\\Desktop> cat .\\countmywords | Measure-Object -Word\n\nLines Words Characters Property\n----- ----- ---------- --------\n        755\n</code></pre>\n<h3>Century 14 -> 15</h3>\n<p>For the last level of this wargame, we simply have to count the number of times the word polo appears inside a file, which is pretty easy to learn how to do with a simple google <a href=\"https://stackoverflow.com/questions/29889495/count-specific-string-in-text-file-using-powershell\">search</a>, so I just adapted the first answer and got what we wanted easily.</p>\n<pre><code class=\"language-powershell\">PS C:\\Users\\century14\\Desktop> ls\n\n\n    Directory: C:\\Users\\century14\\Desktop\n\n\nMode                LastWriteTime         Length Name\n----                -------------         ------ ----\n-a----        8/30/2018  11:24 PM         202900 countpolos\n\nPS C:\\Users\\century14\\Desktop> (cat .\\countpolos | Select-String -Pattern \"polo\"\n -AllMatches).Matches.Count\n158\n</code></pre>\n<h3>Century 15</h3>\n<p>Aaaand... that's all folks. It's the end of this wargame. When I start playing <a href=\"http://underthewire.tech/cyborg/cyborg.htm\">Cyborg</a> i'll throw a link to the write-up in here. Hope this write-up was able to explain what you didn't understand or was able to teach you a new technique or cmdlet you never used.</p>\n<p>Have a good one,</p>\n<p><strong><em>Bernardo Sequeira</em></strong></p>","frontmatter":{"title":""}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/under_the_wire/century/Century_writeup_complete/"}}}